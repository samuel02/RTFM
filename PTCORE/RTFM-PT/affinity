
#include <signal.h>
#include <stdlib.h>
#include <sys/types.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#define handle_error_en(en, msg) do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

static int get_policy(char p, int *policy) {
    switch (p) {
        case 'f': *policy = SCHED_FIFO;
            return 1;
        case 'r': *policy = SCHED_RR;
            return 1;
        case 'o': *policy = SCHED_OTHER;
            return 1;
        default: return 0;
    }
}

static void display_sched_attr(int policy, struct sched_param *param) {
    printf("    policy=%s, priority=%d\n",
            (policy == SCHED_FIFO) ? "SCHED_FIFO" :
            (policy == SCHED_RR) ? "SCHED_RR" :
            (policy == SCHED_OTHER) ? "SCHED_OTHER" :
            "???",
            param->sched_priority);
}

static void display_thread_sched_attr(char *msg) {
    int policy, s;
    struct sched_param param;

    s = pthread_getschedparam(pthread_self(), &policy, &param);
    if (s != 0)
        handle_error_en(s, "pthread_getschedparam");

    printf("%s\n", msg);
    display_sched_attr(policy, &param);
}

static void display_pthread_attr(pthread_attr_t *attr, char *prefix) {
    int s, i;
    size_t v;
    void *stkaddr;
    struct sched_param sp;

    s = pthread_attr_getdetachstate(attr, &i);
    if (s != 0)
        handle_error_en(s, "pthread_attr_getdetachstate");
    printf("%sDetach state        = %s\n", prefix,
            (i == PTHREAD_CREATE_DETACHED) ? "PTHREAD_CREATE_DETACHED" :
            (i == PTHREAD_CREATE_JOINABLE) ? "PTHREAD_CREATE_JOINABLE" :
            "???");

    s = pthread_attr_getscope(attr, &i);
    if (s != 0)
        handle_error_en(s, "pthread_attr_getscope");
    printf("%sScope               = %s\n", prefix,
            (i == PTHREAD_SCOPE_SYSTEM) ? "PTHREAD_SCOPE_SYSTEM" :
            (i == PTHREAD_SCOPE_PROCESS) ? "PTHREAD_SCOPE_PROCESS" :
            "???");

    s = pthread_attr_getinheritsched(attr, &i);
    if (s != 0)
        handle_error_en(s, "pthread_attr_getinheritsched");
    printf("%sInherit scheduler   = %s\n", prefix,
            (i == PTHREAD_INHERIT_SCHED) ? "PTHREAD_INHERIT_SCHED" :
            (i == PTHREAD_EXPLICIT_SCHED) ? "PTHREAD_EXPLICIT_SCHED" :
            "???");

    s = pthread_attr_getschedpolicy(attr, &i);
    if (s != 0)
        handle_error_en(s, "pthread_attr_getschedpolicy");
    printf("%sScheduling policy   = %s\n", prefix,
            (i == SCHED_OTHER) ? "SCHED_OTHER" :
            (i == SCHED_FIFO) ? "SCHED_FIFO" :
            (i == SCHED_RR) ? "SCHED_RR" :
            "???");

    s = pthread_attr_getschedparam(attr, &sp);
    if (s != 0)
        handle_error_en(s, "pthread_attr_getschedparam");
    printf("%sScheduling priority = %d\n", prefix, sp.sched_priority);

    s = pthread_attr_getguardsize(attr, &v);
    if (s != 0)
        handle_error_en(s, "pthread_attr_getguardsize");
    printf("%sGuard size          = %d bytes\n", prefix, v);

    s = pthread_attr_getstack(attr, &stkaddr, &v);
    if (s != 0)
        handle_error_en(s, "pthread_attr_getstack");
    printf("%sStack address       = %p\n", prefix, stkaddr);
    printf("%sStack size          = 0x%x bytes\n", prefix, v);
}

static void thread_info() {
    int s;
    pthread_attr_t gattr;

    /* pthread_getattr_np() is a non-standard GNU extension that
       retrieves the attributes of the thread specified in its
       first argument */

    s = pthread_getattr_np(pthread_self(), &gattr);
    if (s != 0)
        handle_error_en(s, "pthread_getattr_np");

    printf("Thread attributes:\n");
    display_pthread_attr(&gattr, "\t");


}

//
//-----------------------------------------------------------------
//
pthread_mutex_t m;
int conditionMet = 0;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int glob_id; // protected by m, and cond

struct sched_param t1_sp = {1};

/*
void *t1(void *id_ptr) {
    pthread_mutex_lock(&m);
    int id = *((int *) id_ptr);
    fprintf(stderr, "t1 %d\n", id);
    display_thread_sched_attr("t1 :");
    thread_info();
    while (1) {
        fprintf(stderr, "Thread %d blocked\n", id);
        int rc = pthread_cond_wait(&cond, &m);
        if (glob_id == id)
            break;
    }

    fprintf(stderr, "Thread %d released\n", id);
    pthread_mutex_unlock(&m);
    return NULL;
}

struct sched_param t2_sp = { 2 };

void *t2(void *id_ptr) {
    pthread_mutex_lock(&m);
    int id = *((int *) id_ptr);

    printf("t2 %d\n", id);
    fprintf(stderr, "t2 %d\n", id);
    display_thread_sched_attr("t2 :");



    pthread_mutex_unlock(&m);
    glob_id = 1;
    pthread_cond_broadcast(&cond);
    return NULL;
}
 */



void busy_wait(int i, int t) {
    volatile int j, k, l, m;
    int policy, s;
    struct sched_param param;

    for (l = 0; l < i; l++) {
        if (pthread_getschedparam(pthread_self(), &policy, &param))
            handle_error_en(s, "pthread_getschedparam");
        printf("---- task %d, %d, priority %d\n", t, l, param.sched_priority);

        for (j = 0; j < 3000; j++) {
            for (k = 0; k < 100000; k++) {
                m++;
            }
        }
    }
}

void set_cpu(int n) {
    pthread_t thread = pthread_self();
    cpu_set_t cpuset;
    int s;

    CPU_ZERO(&cpuset);
    CPU_SET(n, &cpuset);
    if (s = pthread_setaffinity_np(thread, sizeof (cpu_set_t), &cpuset))
        handle_error_en(s, "pthread_setaffinity_np");
}

void *t1(void *id_ptr) {
    set_cpu(2);
    int s;
    int id = *((int *) id_ptr);
    printf("t1 %d\n", id);
    display_thread_sched_attr("t1 :");
    //thread_info();

    printf("t1 lock m\n");
    if (s = pthread_mutex_lock(&m))
        handle_error_en(s, "t1 lock m");

    busy_wait(3, 1);
    printf("t1 unlock m\n");

    if (s = pthread_mutex_unlock(&m))
        handle_error_en(s, "t1 unlock m");

    busy_wait(3, 1);

    return NULL;
}

void *t2(void *id_ptr) {
    set_cpu(2);
    int s;
    int id = *((int *) id_ptr);

    printf("t2 %d\n", id);
    display_thread_sched_attr("t2 :");
    //thread_info();

    printf("t2 lock m\n");
    if (s = pthread_mutex_lock(&m))
        handle_error_en(s, "t2 lock m");

    busy_wait(5, 2);
    printf("t2 unlock m\n");

    if (s = pthread_mutex_unlock(&m))
        handle_error_en(s, "t2 unlock m");
    return NULL;
}

void *t3(void *id_ptr) {
    set_cpu(2);
    int s;
    int id = *((int *) id_ptr);

    printf("t3 %d\n", id);
    display_thread_sched_attr("t3 :");
    //thread_info();

    busy_wait(5, 3);

    return NULL;
}

int main() {
    int policy = SCHED_FIFO; // SCHED_RR; //SCHED_OTHER;
    int p_max = sched_get_priority_max(policy);
    int p_min = sched_get_priority_min(policy);
    cpu_set_t cpuset;
    int s, j;

    pthread_t thread = pthread_self();

    /* Set affinity mask to include CPUs 0 to 7 */

    CPU_ZERO(&cpuset);
    CPU_SET(0, &cpuset);
    if (s = pthread_setaffinity_np(thread, sizeof (cpu_set_t), &cpuset))
        handle_error_en(s, "pthread_setaffinity_np");

    /* Check the actual affinity mask assigned to the thread */

    if (s = pthread_getaffinity_np(thread, sizeof (cpu_set_t), &cpuset))
        handle_error_en(s, "pthread_getaffinity_np");

    printf("Set returned by pthread_getaffinity_np() contained:\n");
    for (j = 0; j < CPU_SETSIZE; j++)
        if (CPU_ISSET(j, &cpuset))
            printf("    CPU %d\n", j);



    printf("start \np_max %d\n p_min %d ;\n", p_max, p_min);

    struct sched_param param;

    pthread_t t1_thread;
    pthread_t t2_thread;
    pthread_t t3_thread;

    int id1 = 1;
    int id2 = 2;
    int id3 = 3;

    pthread_attr_t attr;

    if (s = pthread_attr_init(&attr))
        handle_error_en(s, "attr_init");


    if (s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED))
        handle_error_en(s, "pthread_attr_setinheritsched");

    pthread_mutexattr_t mutexattr;

    pthread_mutexattr_init(&mutexattr);

    //if (s = pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_RECURSIVE))
    //    handle_error_en(s, "pthread_mutexattr_settype\n");


    //    if (s = pthread_mutexattr_setprotocol(&mutexattr, PTHREAD_PRIO_INHERIT))
    //        handle_error_en(s, "pthread_mutexattr_setprotocol\n");
    if (s = pthread_mutexattr_setprotocol(&mutexattr, PTHREAD_PRIO_PROTECT))
        handle_error_en(s, "pthread_mutexattr_setprotocol\n");

    if (s = pthread_mutexattr_setprioceiling(&mutexattr, 35))
        handle_error_en(s, "pthread_mutexattr_setprioceiling\n");

    if (s = pthread_mutex_init(&m, &mutexattr))
        handle_error_en(s, "init mutex\n");


    if (s = pthread_attr_setschedpolicy(&attr, policy))
        handle_error_en(s, "pthread_attr_setschedpolicy");

    // t1
    param.sched_priority = 1;

    if (s = pthread_attr_setschedparam(&attr, &param))
        handle_error_en(s, "pthread_attr_setschedparam");

    if (s = pthread_create(&t1_thread, &attr, t1, &id1))
        handle_error_en(s, "creating thread t1\n");

    printf("t1 created\n");

    sleep (1);
    // t3
    param.sched_priority = 4;

    if (s = pthread_attr_setschedparam(&attr, &param))
        handle_error_en(s, "pthread_attr_setschedparam");

    if (s = pthread_create(&t3_thread, &attr, t3, &id3))
        handle_error_en(s, "creating thread t3\n");


    // t2
    param.sched_priority = 3;

    if (s = pthread_attr_setschedparam(&attr, &param))
        handle_error_en(s, "pthread_attr_setschedparam");

    if (s = pthread_create(&t2_thread, &attr, t2, &id2))
        handle_error_en(s, "creating thread t2\n");


    printf("all threads started\n");


    if (s = pthread_join(t1_thread, NULL)) {
        handle_error_en(s, "joining thread t1\n");
        return 2;

    }
    if (pthread_join(t2_thread, NULL)) {
        handle_error_en(s, "joining thread\n");
        return 2;
    }

    if (pthread_join(t3_thread, NULL)) {
        handle_error_en(s, "joining thread\n");
        return 2;
    }

    printf("------------ threads ended\n");

    return 0;
}
